<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>Program 12, CSci 39542: Data Science, Hunter College</title>
</head>
<STYLE>A {text-decoration: none;}
th, td { padding: 5px; }
code {
  background-color: #eeeeee;
}
.inline {
  padding: 1px;
}
.blockcode {
  border: 1px solid #999999;
  display: block;
  padding-left: 10px;
  padding-top : 2px;
  padding-bottom : 2px;
  margin: 5px;
}
.datablock {
  border: 1px solid #eeeeee;
  display: block;
  padding: 7px;
  padding-top : 0px;
  margin: 5px;
}
</STYLE>
<body>


<div style="margin: 15px;width=100%;">
    <span style= "float: left;font-size:larger"><a href="index.html">CSci 39542</a></span>
    <span style= "float: right">
      <a href="syl.html">Syllabus</a>&nbsp;&nbsp;&nbsp;
      <a href="resources.html">Resources</a>&nbsp;&nbsp;&nbsp;
      <a href="work.html">Coursework</a><!--&nbsp;&nbsp;&nbsp;
      <a href="faq.html">FAQ</a>-->
    </span>
</div>

<br>
<br>
<hr>

<div style="margin:50px">


<h2>Program 12: EMS Stations
  <br>CSci 39542: Introduction to Data Science<br>
<a href="http://www.hunter.cuny.edu/csci">Department of Computer Science</a><br>
<a href="https://hunter.cuny.edu">Hunter College</a>, <a href="https://www.cuny.edu">City University of New York</a><br>
Spring 2022<br><br>
</h2>


<hr>
<a href="work.html#cw">Classwork</a>&nbsp;&nbsp;&nbsp;
<a href="work.html#quizzes">Quizzes</a>&nbsp;&nbsp;&nbsp;
<a href="work.html#hw">Homework</a>&nbsp;&nbsp;&nbsp;
<a href="work.html#project">Project</a>&nbsp;&nbsp;&nbsp;
<hr>

<object width=100% height=50% type="text/html" data="generalNotes.html" border="0"
   style="overflow: hidden;">
</object>
<hr>

<h2>Program Description</h2>

<br>
   <p><a name="p12"><b>Program 12: EMS Stations.</b></b> &emsp; <i>Due noon, Thursday, 5 May.
     <br>Learning Objective: to enhance data cleaning skills and build understanding of clustering algorithms.
     <br>Available Libraries: pandas, numpy, sklearn, and core Python 3.6+.
     <br>Data Sources: <a href="https://data.cityofnewyork.us/Public-Safety/NYPD-Calls-for-Service-Year-to-Date-/n2zq-pubd
">911 System Calls (NYC OpenData)</a>
     <br>Sample Datasets:.<br></i>

<!--
https://data.cityofnewyork.us/Public-Safety/Emergency-Response-Incidents/pasr-j7fb
Calls for 911 service:
https://data.cityofnewyork.us/Public-Safety/NYPD-Calls-for-Service-Year-to-Date-/n2zq-pubd

Can get time of incident and date, get day of week?

https://data.cityofnewyork.us/Public-Safety/EMS-Incident-Dispatch-Data/76xm-jjuj
-->

<p> For this program, we are focusing on ambulance calls in New York City.
Decreasing ambulance response times improves outcomes and
<a href="https://www.sciencedirect.com/science/article/pii/S1386505619303491">strategic placement</a> of ambulance stations and overall allocation has been shown an effective approach.

<p>IMAGE/folium of ambulances over one night.

<p>To decide on where to "pre-place" ambulances, we will use K-means clustering, where "K" is the number of ambulances available for that shift.  For example, if there 8 ambulances available to be placed in eastern Queens, we will look at previous ambulance calls for that shift and form 8 clusters and station each ambulance at the mean of the cluster.  If two more ambulances become available, we can recompute the K-means algorithm for K=10, and place those 10 ambulances, each at the mean of the cluster found.

<p>
In Lecture #25 and <a href="https://jakevdp.github.io/PythonDataScienceHandbook/05.11-k-means.html">Python Data Science Handbook: Section 5.11</a>, we clustered the digits data set using K-means clustering and used t-SNE to improve accuracy.

<p>
For this program, modify the code from lecture to write a function that allows you to run three different preprocessing of a toy dataset ("none", "TSNE", or "MDS"), applies K-Means clustering, takes the mode of each cluster as the predicted label, and then returns the accuracy of the prediction.

<p>The assignment is broken into the following functions to allow for unit testing:

  <ul>
    <li> <code class = "inline">make_df(file_name)</code>:
      This function takes one input:
      <ul>
        <li> <code class = "inline">file_name</code>: the name of a CSV file containing <a href="https://data.cityofnewyork.us/Public-Safety/NYPD-Calls-for-Service-Year-to-Date-/n2zq-pubd">911 System Calls</a> from OpenData NYC.
      </ul>
      The data is read into DataFrame.  Rows that are have null values for the type description, incident date, and latitue and longitude are dropped.
      Only rows that contain <code class = "inline">AMBULANCE</code> as part of the <code class = "inline">TYP_DESC</code> are kept differs from 2010, that row is dropped.  An additional column <code class = "inline">WEEK_DAY</code> is added with the day of the week, 0 for Monday, 1 for Tuesday, ..., 6 for Sunday, of the date in <code class = "inline">INCIDENT_DATE</code> is added.  The resulting DataFrame is returned.

    <li> <code class = "inline">filter_by_time(df,days=None,times=[0,1439])</code>:
      This function takes three inputs:
      <ul>
        <li> <code class = "inline">df</code>: a DataFrame containing <a href="https://data.cityofnewyork.us/Public-Safety/NYPD-Calls-for-Service-Year-to-Date-/n2zq-pubd">911 System Calls</a> from OpenData NYC.
        <li> <code class = "inline">days</code>:  a list of integers ranging from 0 to 6, representing the days of the week.  The default value is <code class = "inline">None</code> and is equivalent to the list containing all days:
        <code class = "inline">[0,1,2,3,4,5,6]</code>.
        <li> <code class = "inline">times</code>:  a list of two non-negative integer values representing the range for the time, in minutes, that should be selected.  The default value is <code class = "inline">[0,1440]</code> which ranges from midnight (<code class = "inline">0</code> minutes) to (<code class = "inline">1439</code> representing 11:59 since 11 hours + 59 minutes = 1439 minutes).
      </ul>
       filter data by time stamps and day of the week-- use only calls during shift?
    <li> <code class = "inline">compute_dist_mx(df)</code>:
      This function takes one input:
    <ul>
      <li> <code class = "inline">df</code>: a DataFrame containing <a href="https://data.cityofnewyork.us/Public-Safety/NYPD-Calls-for-Service-Year-to-Date-/n2zq-pubd">911 System Calls</a> from OpenData NYC.
    </ul>
    Compute distances with Haversine correction.  Assumes no null entries in latitudes and longitudes.  Returns the computed distance matrx as a numpy array.  The ordering of the distances between entries is the same order as the entries appear in the DataFrame.
    <li> <code class = "inline">compute_means(dist_mx)</code>:  Compute distances with Haversine correction.

        <p>make predictions-- and correct via haversine corrections
        <p>measure accuracy?

<ul>
<li> <code class = "inline">clusterDemo(toy_dataset, n_components = 2, n_clusters = 3, method = "none", random_state=0):</code>
    This function has five inputs and returns the accuracy (value between 0 and 1):
    <ul>
        <li> <code class = "inline">toy_dataset</code>: a dataset from the sklearn toy datasets (see above).  Assumes that the dataset is of type
        <code class = "inline">sklearn.utils.Bunch</code> and has fields
        <code class = "inline">data</code> and
        <code class = "inline">target</code>.
        <li> <code class = "inline">n_components</code>: the number of components for the MDS or t-SNE analysis.  The default value is <code class = "inline">2</code>.
        <li> <code class = "inline">n_clusters</code>: the number of components for the K-Means analysis.  The default value is <code class = "inline">3</code>.
        <li> <code class = "inline">method</code>: the method used for preprocessing the data.  Possible values are <code class = "inline">"none"</code> (which does no preprocessing), <code class = "inline">"MDS"</code> (which uses MDS to preprocess), and
        <code class = "inline">"TSNE"</code>.The default value is <code class = "inline">"none"</code>.
        <li> <code class = "inline">random_state</code>: the random seed for MDS, TSNE, and K-Means clustering methods.  The default value is <code class = "inline">0</code>.
      </ul>
      The function should:
      <ol>
          <li> Preprocess the dataset via the method specified.  If method is <code class = "inline">"none"</code>, then the original data is used.
          <li> Run the K-means clustering method on the data.
          <li> Label each element by the most common label for its cluster (i.e. the mode of the labels).
          <li> Return the accuracy of the predicted labels versus the actual labels in the dataset.
  </ul>

  <p>For example, assuming your functions are in <code class=inline>p49</code> and the appropriate libraries are loaded, we can run the function on the relatively small datasets of iris species and wine classifications:
  <pre><code class="blockcode">iris = datasets.load_iris()
no_preproc = p49.clusterDemo(iris)
print(f'Iris:  The accuracy with no-preprocessing is {no_preproc}.')
tsne_proc = p49.clusterDemo(iris, method = "TSNE")
print(f'Iris: The accuracy with TSNE preprocessing is {tsne_proc}.')
mds_proc = p49.clusterDemo(iris, method = "MDS")
print(f'Iris: The accuracy with MDS preprocessing is {mds_proc}.')

wine = datasets.load_wine()
no_preproc = p49.clusterDemo(wine, n_components = 3, random_state=10)
print(f'Wine:  The accuracy with no-preprocessing is {no_preproc}.')
tsne_proc = p49.clusterDemo(wine, n_components = 3, method = "TSNE", random_state=10)
print(f'Wine: The accuracy with TSNE preprocessing is {tsne_proc}.')</code></pre>

  would print:
  <pre><code class="datablock">Iris:  The accuracy with no-preprocessing is 0.8933333333333333.
Iris: The accuracy with TSNE preprocessing is 0.9133333333333333.
Iris: The accuracy with MDS preprocessing is 0.9.
Wine:  The accuracy with no-preprocessing is 0.702247191011236.
Wine: The accuracy with TSNE preprocessing is 0.6797752808988764.</code></pre>

  <p>We can also run on the digits dataset.  It's larger and the t-SNE and MDS methods will take a bit of time to return their answers:
  <pre><code class="blockcode">digits = datasets.load_digits()
no_preproc = p49.clusterDemo(digits, n_clusters = 10, method = "none", random_state=20)
print(f'Digits: The accuracy with no-preprocessing is {no_preproc}.')
tsne_proc = p49.clusterDemo(digits, n_clusters = 10, method = "TSNE", random_state=20)
print(f'Digits: The accuracy with TSNE preprocessing is {tsne_proc}.')
mds_proc = p49.clusterDemo(digits, n_clusters = 10, method = "MDS", random_state=20)
print(f'Digits: The accuracy with MDS preprocessing is {mds_proc}.')</code></pre>

  would print:
  <pre><code class="datablock">Digits: The accuracy with no-preprocessing is 0.7946577629382304.
Digits: The accuracy with TSNE preprocessing is 0.9432387312186978.
Digits: The accuracy with MDS preprocessing is 0.676126878130217.</code></pre>


<p><i>Hints:
  <ul>
    <li> The import statements needed for the function are:
      <pre><code class="blockcode">import pandas as pd
import numpy as np
from sklearn.manifold import TSNE, MDS
from sklearn.cluster import KMeans
from scipy.stats import mode
from sklearn.metrics import accuracy_score</code></pre>
    <li> Both the MDS and t-SNE methods use the <code class=inline>n_components</code> when instantiating the model.  Not passing this parameter to the functions will give different answers.
    <li> The <code class=inline>random_state</code> parameter is used by both the preprocessing steps (MDS and t-SNE) as well as for the K-Means clustering.  Not passing this parameter to the functions will give different answers.
  </ul>
</i>


</div>
</body>
</html>
